{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"webtypes This is a fork of API Star 0.5.* Community: https://discuss.apistar.org/ \ud83e\udd14 \ud83d\udcad \ud83e\udd13 \ud83d\udcac \ud83d\ude0e Repository : https://github.com/abetkin/webtypes \ud83d\udcbb Quickstart Install webtypes: $ pip3 install webtypes Create a new project in app.py : from webtypes import App, Route def welcome(name=None): if name is None: return {'message': 'Welcome to webtypes!'} return {'message': 'Welcome to webtypes, %s!' % name} routes = [ Route('/', method='GET', handler=welcome), ] app = App(routes=routes) if __name__ == '__main__': app.serve('127.0.0.1', 5000, debug=True) Open http://127.0.0.1:5000/docs/ in your browser:","title":"Home"},{"location":"#webtypes","text":"This is a fork of API Star 0.5.* Community: https://discuss.apistar.org/ \ud83e\udd14 \ud83d\udcad \ud83e\udd13 \ud83d\udcac \ud83d\ude0e Repository : https://github.com/abetkin/webtypes \ud83d\udcbb","title":"webtypes"},{"location":"#quickstart","text":"Install webtypes: $ pip3 install webtypes Create a new project in app.py : from webtypes import App, Route def welcome(name=None): if name is None: return {'message': 'Welcome to webtypes!'} return {'message': 'Welcome to webtypes, %s!' % name} routes = [ Route('/', method='GET', handler=welcome), ] app = App(routes=routes) if __name__ == '__main__': app.serve('127.0.0.1', 5000, debug=True) Open http://127.0.0.1:5000/docs/ in your browser:","title":"Quickstart"},{"location":"api-guide/api-schemas/","text":"API Schemas By default webtypes will serve an Open API schema for your application, at '/schema/' . Let's take a look at that with a short example... from webtypes import App, Route def welcome(name=None): if name is None: return {'message': 'Welcome to webtypes!'} return {'message': 'Welcome to webtypes, %s!' % name} routes = [ Route('/', method='GET', handler=welcome), ] app = App(routes=routes) if __name__ == '__main__': app.serve('127.0.0.1', 8080, use_debugger=True) Start the application running... $ python ./example.py * Running on http://127.0.0.1:8080/ (Press CTRL+C to quit) And download the schema... $ curl http://127.0.0.1:8080/schema/ { \"openapi\": \"3.0.0\", \"info\": { \"title\": \"\", \"description\": \"\", \"version\": \"\" }, \"paths\": { \"/\": { \"get\": { \"operationId\": \"welcome\", \"parameters\": [ { \"name\": \"name\", \"in\": \"query\" } ] } } } } You can disable the schema generation by using the schema_url argument. app = App(routes=routes, schema_url=None)","title":"API Schemas"},{"location":"api-guide/api-schemas/#api-schemas","text":"By default webtypes will serve an Open API schema for your application, at '/schema/' . Let's take a look at that with a short example... from webtypes import App, Route def welcome(name=None): if name is None: return {'message': 'Welcome to webtypes!'} return {'message': 'Welcome to webtypes, %s!' % name} routes = [ Route('/', method='GET', handler=welcome), ] app = App(routes=routes) if __name__ == '__main__': app.serve('127.0.0.1', 8080, use_debugger=True) Start the application running... $ python ./example.py * Running on http://127.0.0.1:8080/ (Press CTRL+C to quit) And download the schema... $ curl http://127.0.0.1:8080/schema/ { \"openapi\": \"3.0.0\", \"info\": { \"title\": \"\", \"description\": \"\", \"version\": \"\" }, \"paths\": { \"/\": { \"get\": { \"operationId\": \"welcome\", \"parameters\": [ { \"name\": \"name\", \"in\": \"query\" } ] } } } } You can disable the schema generation by using the schema_url argument. app = App(routes=routes, schema_url=None)","title":"API Schemas"},{"location":"api-guide/applications/","text":"Applications The first thing you'll always need to do when creating a new webtypes service is to create an application instance. Here's an example that just returns a simple HTML homepage: from webtypes import App, Route def homepage() -> str: return '<html><body><h1>Homepage</h1></body></html>' routes = [ Route('/', method='GET', handler=homepage), ] app = App(routes=routes) Sync or ASync webtypes supports both multi-threaded (WSGI) and asyncio (ASGI) modes of operation. The Python ecosystem currently has far more support for multi-threaded concurrency. Most existing database adapters, ORMs, and other networking components are designed to work within this context. If you're not sure which of the two modes you want, then you probably want to use the standard App instance. For IO-bound web services where you need particularly high throughput you might want to choose the asyncio mode. If you do so then you'll need to make sure that you're only ever making network requests or disk access using async operations, and packages designed to work with asyncio. For an asyncio-based application, you should use the ASyncApp class. Once you're using ASyncApp you'll be able to route to either standard functions, or to async functions. from webtypes import ASyncApp, Route async def hello_world() -> dict: # We can perform some network I/O here, asyncronously. return {'hello': 'async'} routes = [ Route('/', method='GET', handler=hello_world) ] app = ASyncApp(routes=routes) The development server To run the development server, you should include something like the following in your app.py module. if __name__ == '__main__': app.serve('127.0.0.1', 5000, debug=True) If debug is set to True , then the interactive debugger will be triggered on exceptions. If debug is not set, then exceptions will result in a 500 Server Error. You should only use app.serve() for local development. See the deployment documentation for information on running webtypes in production.","title":"Applications"},{"location":"api-guide/applications/#applications","text":"The first thing you'll always need to do when creating a new webtypes service is to create an application instance. Here's an example that just returns a simple HTML homepage: from webtypes import App, Route def homepage() -> str: return '<html><body><h1>Homepage</h1></body></html>' routes = [ Route('/', method='GET', handler=homepage), ] app = App(routes=routes)","title":"Applications"},{"location":"api-guide/applications/#sync-or-async","text":"webtypes supports both multi-threaded (WSGI) and asyncio (ASGI) modes of operation. The Python ecosystem currently has far more support for multi-threaded concurrency. Most existing database adapters, ORMs, and other networking components are designed to work within this context. If you're not sure which of the two modes you want, then you probably want to use the standard App instance. For IO-bound web services where you need particularly high throughput you might want to choose the asyncio mode. If you do so then you'll need to make sure that you're only ever making network requests or disk access using async operations, and packages designed to work with asyncio. For an asyncio-based application, you should use the ASyncApp class. Once you're using ASyncApp you'll be able to route to either standard functions, or to async functions. from webtypes import ASyncApp, Route async def hello_world() -> dict: # We can perform some network I/O here, asyncronously. return {'hello': 'async'} routes = [ Route('/', method='GET', handler=hello_world) ] app = ASyncApp(routes=routes)","title":"Sync or ASync"},{"location":"api-guide/applications/#the-development-server","text":"To run the development server, you should include something like the following in your app.py module. if __name__ == '__main__': app.serve('127.0.0.1', 5000, debug=True) If debug is set to True , then the interactive debugger will be triggered on exceptions. If debug is not set, then exceptions will result in a 500 Server Error. You should only use app.serve() for local development. See the deployment documentation for information on running webtypes in production.","title":"The development server"},{"location":"api-guide/dependency-injection/","text":"Dependency Injection webtypes allows you to include various parameters on handler functions and event hooks, and will automatically provide those parameters as required. You can add additional components, making them available to handler functions if they are included in an annotation. Here's an example that makes the User annotation available to handler functions. from webtypes import App, Route, exceptions, http from webtypes.server.components import Component class User(object): def __init__(self, username: str): self.username = username class UserComponent(Component): def resolve(self, authorization: http.Header) -> User: \"\"\" Determine the user associated with a request, using HTTP Basic Authentication. \"\"\" if authorization is None: return None scheme, token = authorization.split() if scheme.lower() != 'basic': return None username, password = base64.b64decode(token).decode('utf-8').split(':') if not self.check_authentication(username, password): raise exceptions.Forbidden('Incorrect username or password.') return User(username) def check_authentication(self, username: str, password: str) -> bool: # Just an example here. You'd normally want to make a database lookup, # and check against a hash of the password. return password == 'secret' def hello_user(user: User=None) -> dict: return {'hello': user.username if user else None} routes = [ Route('/', method='GET', handler=hello_user) ] components = [UserComponent()] app = App(routes=routes, components=components) You can combine components and event hooks in order to have a component that always runs, regardless of if it is used in a handler function. class MustBeAuthenticated(): def on_request(self, user: User=None) -> None: if user is None: raise exceptions.NotAuthenticated() def hello_user(user: User) -> dict: return {'hello': user.username} routes = [ Route('/', method='GET', handler=hello_user) ] components = [UserComponent()] event_hooks = [MustBeAuthenticated()] app = App(routes=routes, components=components, event_hooks=event_hooks) Reference The following components are already installed by default. Class Notes http.Method The http method, as an uppercased string. http.URL The full request URL, as a string-like object. http.Scheme The scheme, either http or https . http.Host The server hostname, as a string. http.Port The server port, as an integer. http.Path The URL path, excluding any querystring. http.QueryString The querystring from the URL. eg. \"color=red&size=medium\". http.QueryParam A single query parameter, looked up against the parameter name. http.Headers A multidict http.Header A single query parameter, looked up against the parameter name. http.Body The request body, as a bytestring. http.Request The incoming request. Includes url , method , headers , and body attributes. http.Response The outgoing response. Only available to event hooks that run after the main handler function. http.PathParams The matched path parameters for the incoming request. App The current application. Made available as App for both multithreaded and async applications. Route The matched route for the incoming request. Exception None unless exception handling is running. server.wsgi.WSGIEnviron Only for App . server.wsgi.WSGIStartResponse Only for App . server.asgi.ASGIScope Only for ASyncApp . server.asgi.ASGIReceive Only for ASyncApp . server.asgi.ASGISend Only for ASyncApp . server.components.ReturnValue Used internally to access the return value of the preceeding function in a dependency injection chain.","title":"Dependency Injection"},{"location":"api-guide/dependency-injection/#dependency-injection","text":"webtypes allows you to include various parameters on handler functions and event hooks, and will automatically provide those parameters as required. You can add additional components, making them available to handler functions if they are included in an annotation. Here's an example that makes the User annotation available to handler functions. from webtypes import App, Route, exceptions, http from webtypes.server.components import Component class User(object): def __init__(self, username: str): self.username = username class UserComponent(Component): def resolve(self, authorization: http.Header) -> User: \"\"\" Determine the user associated with a request, using HTTP Basic Authentication. \"\"\" if authorization is None: return None scheme, token = authorization.split() if scheme.lower() != 'basic': return None username, password = base64.b64decode(token).decode('utf-8').split(':') if not self.check_authentication(username, password): raise exceptions.Forbidden('Incorrect username or password.') return User(username) def check_authentication(self, username: str, password: str) -> bool: # Just an example here. You'd normally want to make a database lookup, # and check against a hash of the password. return password == 'secret' def hello_user(user: User=None) -> dict: return {'hello': user.username if user else None} routes = [ Route('/', method='GET', handler=hello_user) ] components = [UserComponent()] app = App(routes=routes, components=components) You can combine components and event hooks in order to have a component that always runs, regardless of if it is used in a handler function. class MustBeAuthenticated(): def on_request(self, user: User=None) -> None: if user is None: raise exceptions.NotAuthenticated() def hello_user(user: User) -> dict: return {'hello': user.username} routes = [ Route('/', method='GET', handler=hello_user) ] components = [UserComponent()] event_hooks = [MustBeAuthenticated()] app = App(routes=routes, components=components, event_hooks=event_hooks)","title":"Dependency Injection"},{"location":"api-guide/dependency-injection/#reference","text":"The following components are already installed by default. Class Notes http.Method The http method, as an uppercased string. http.URL The full request URL, as a string-like object. http.Scheme The scheme, either http or https . http.Host The server hostname, as a string. http.Port The server port, as an integer. http.Path The URL path, excluding any querystring. http.QueryString The querystring from the URL. eg. \"color=red&size=medium\". http.QueryParam A single query parameter, looked up against the parameter name. http.Headers A multidict http.Header A single query parameter, looked up against the parameter name. http.Body The request body, as a bytestring. http.Request The incoming request. Includes url , method , headers , and body attributes. http.Response The outgoing response. Only available to event hooks that run after the main handler function. http.PathParams The matched path parameters for the incoming request. App The current application. Made available as App for both multithreaded and async applications. Route The matched route for the incoming request. Exception None unless exception handling is running. server.wsgi.WSGIEnviron Only for App . server.wsgi.WSGIStartResponse Only for App . server.asgi.ASGIScope Only for ASyncApp . server.asgi.ASGIReceive Only for ASyncApp . server.asgi.ASGISend Only for ASyncApp . server.components.ReturnValue Used internally to access the return value of the preceeding function in a dependency injection chain.","title":"Reference"},{"location":"api-guide/deployment/","text":"Deployment The Development Server You'll want to make sure to include app.serve() in your main app.py module: if __name__ == '__main__': app.serve('127.0.0.1', 5000, use_debugger=True, use_reloader=True) For development you can now just run the application directly. $ python app.py * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit) Running in Production Which webserver you use depends on if you're running App or ASyncApp . For App you can use any WSGI based webserver. Both gunicorn and uwsgi are good options. For ASyncApp you'll want to use an ASGI based webserver. Your options here are uvicorn or daphne .","title":"Deployment"},{"location":"api-guide/deployment/#deployment","text":"","title":"Deployment"},{"location":"api-guide/deployment/#the-development-server","text":"You'll want to make sure to include app.serve() in your main app.py module: if __name__ == '__main__': app.serve('127.0.0.1', 5000, use_debugger=True, use_reloader=True) For development you can now just run the application directly. $ python app.py * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)","title":"The Development Server"},{"location":"api-guide/deployment/#running-in-production","text":"Which webserver you use depends on if you're running App or ASyncApp . For App you can use any WSGI based webserver. Both gunicorn and uwsgi are good options. For ASyncApp you'll want to use an ASGI based webserver. Your options here are uvicorn or daphne .","title":"Running in Production"},{"location":"api-guide/event-hooks/","text":"Event Hooks Sometimes you'll want to always run some code before or after a handler function. webtypes provides something very similar to middleware, that lets you register a group of functions to be run in response to particular events. Here's an example... class CustomHeadersHook: def on_response(self, response: http.Response): response.headers['x-custom'] = 'Ran on_response()' event_hooks = [CustomHeadersHook] app = App(routes=routes, event_hooks=event_hooks) An event hook instance may include any or all of the following methods: on_request(self, ...) - Runs before the handler function. on_response(self, ...) - Runs after the handler function, or when a handled exception occurs. on_error(self, ...) - Runs after any unhandled exception occurs. The signature of the method may include any annotations that would be available on a handler function, or the http.Response annotation. Error handling Subclasses of HTTPException are dealt with by the applications exception handler, and return responses, that pass through any on_response hooks as usual. Unhandled exceptions result in server errors, and should be treated differently. For these cases, any installed on_error event hooks will be run. This event hook allows you to monitor or log exceptions. It's recommend that use of on_error event hooks should be kept to a minimum, dealing only with whatever error monitoring is required. Using event hooks Event hooks can pull in components such as the request, the returned response, or the exception that resulted in a response. For example: class ErrorHandlingHook: def on_response(self, response: http.Response, exc: Exception): if exc is None: print(\"Handler returned a response\") else: print(\"Exception handler returned a response\") def on_error(self, response: http.Response): print(\"An unhandled error was raised\") app = App(routes=routes, event_hooks=[ErrorHandlingHook]) Event hooks are instantiated at the start of every request/response cycle, and can store state between the request and response events. class TimingHook: def on_request(self): self.started = time.time() def on_response(self): duration = time.time() - self.started print(\"Response returned in %0.6f seconds.\" % duration) app = App(routes=routes, event_hooks=[TimingHook]) Ordering of event hooks The on_request hooks are run in the order that their classes are included. The on_response and on_error hooks are run in the reverse order that their classes are included. This behaviour ensures that event hooks run in a similar manner to stack-based middleware, with the each event hook wrapping everything that comes after it.","title":"Event Hooks"},{"location":"api-guide/event-hooks/#event-hooks","text":"Sometimes you'll want to always run some code before or after a handler function. webtypes provides something very similar to middleware, that lets you register a group of functions to be run in response to particular events. Here's an example... class CustomHeadersHook: def on_response(self, response: http.Response): response.headers['x-custom'] = 'Ran on_response()' event_hooks = [CustomHeadersHook] app = App(routes=routes, event_hooks=event_hooks) An event hook instance may include any or all of the following methods: on_request(self, ...) - Runs before the handler function. on_response(self, ...) - Runs after the handler function, or when a handled exception occurs. on_error(self, ...) - Runs after any unhandled exception occurs. The signature of the method may include any annotations that would be available on a handler function, or the http.Response annotation.","title":"Event Hooks"},{"location":"api-guide/event-hooks/#error-handling","text":"Subclasses of HTTPException are dealt with by the applications exception handler, and return responses, that pass through any on_response hooks as usual. Unhandled exceptions result in server errors, and should be treated differently. For these cases, any installed on_error event hooks will be run. This event hook allows you to monitor or log exceptions. It's recommend that use of on_error event hooks should be kept to a minimum, dealing only with whatever error monitoring is required.","title":"Error handling"},{"location":"api-guide/event-hooks/#using-event-hooks","text":"Event hooks can pull in components such as the request, the returned response, or the exception that resulted in a response. For example: class ErrorHandlingHook: def on_response(self, response: http.Response, exc: Exception): if exc is None: print(\"Handler returned a response\") else: print(\"Exception handler returned a response\") def on_error(self, response: http.Response): print(\"An unhandled error was raised\") app = App(routes=routes, event_hooks=[ErrorHandlingHook]) Event hooks are instantiated at the start of every request/response cycle, and can store state between the request and response events. class TimingHook: def on_request(self): self.started = time.time() def on_response(self): duration = time.time() - self.started print(\"Response returned in %0.6f seconds.\" % duration) app = App(routes=routes, event_hooks=[TimingHook])","title":"Using event hooks"},{"location":"api-guide/event-hooks/#ordering-of-event-hooks","text":"The on_request hooks are run in the order that their classes are included. The on_response and on_error hooks are run in the reverse order that their classes are included. This behaviour ensures that event hooks run in a similar manner to stack-based middleware, with the each event hook wrapping everything that comes after it.","title":"Ordering of event hooks"},{"location":"api-guide/requests-and-responses/","text":"Requests and Responses Requests To access the incoming HTTP request, use the http.Request class as an annotation on the handler function. from webtypes import http def echo_request_info(request: http.Request) -> dict: return { 'method': request.method, 'url': request.url, 'headers': dict(request.headers), 'body': request.body.decode('utf-8') } webtypes allows you to dynamically inject various other information about the incoming request into your views using type annotation. from webtypes import http def echo_query_params(query_params: http.QueryParams) -> dict: return { 'params': dict(query_params) } def echo_user_agent(user_agent: http.Header) -> dict: return { 'user-agent': user_agent } Some of the components you might use most often: Component Description http.Request The HTTP request. Includes .method , .url , and .headers attributes. http.Headers The request headers, returned as a dictionary-like object. http.Header Lookup a single request header, corresponding to the argument name. Returns a string or None . http.QueryParams The request query parameters, returned as a dictionary-like object. http.QueryParam Lookup a single query parameter, corresponding to the argument name. Returns a string or None . http.Body The request body, as a bytestring. Responses By default API star uses HTML responses for handlers that return strings, and JSON responses for anything else. def hello_world() -> dict: return {'text': 'Hello, world!'} For more control over the response use the JSONResponse and HTMLResponse classes. from webtypes import http def hello_world(accept_language: http.Header) -> http.JSONResponse: if 'de' in accept_language: data = {'text': 'Hallo, Welt!'} else: data = {'text': 'Hello, world!'} headers = {'Vary': 'Accept-Language'} return http.JSONResponse(data, status_code=200, headers=headers) For other content types, use a Response class, and set the content-type header explicitly. from webtypes import http def hello_world() -> http.Response: content = 'Hello, world!' headers = {'Content-Type': 'text/plain'} return http.Response(content, headers=headers)","title":"Requests and Responses"},{"location":"api-guide/requests-and-responses/#requests-and-responses","text":"","title":"Requests and Responses"},{"location":"api-guide/requests-and-responses/#requests","text":"To access the incoming HTTP request, use the http.Request class as an annotation on the handler function. from webtypes import http def echo_request_info(request: http.Request) -> dict: return { 'method': request.method, 'url': request.url, 'headers': dict(request.headers), 'body': request.body.decode('utf-8') } webtypes allows you to dynamically inject various other information about the incoming request into your views using type annotation. from webtypes import http def echo_query_params(query_params: http.QueryParams) -> dict: return { 'params': dict(query_params) } def echo_user_agent(user_agent: http.Header) -> dict: return { 'user-agent': user_agent } Some of the components you might use most often: Component Description http.Request The HTTP request. Includes .method , .url , and .headers attributes. http.Headers The request headers, returned as a dictionary-like object. http.Header Lookup a single request header, corresponding to the argument name. Returns a string or None . http.QueryParams The request query parameters, returned as a dictionary-like object. http.QueryParam Lookup a single query parameter, corresponding to the argument name. Returns a string or None . http.Body The request body, as a bytestring.","title":"Requests"},{"location":"api-guide/requests-and-responses/#responses","text":"By default API star uses HTML responses for handlers that return strings, and JSON responses for anything else. def hello_world() -> dict: return {'text': 'Hello, world!'} For more control over the response use the JSONResponse and HTMLResponse classes. from webtypes import http def hello_world(accept_language: http.Header) -> http.JSONResponse: if 'de' in accept_language: data = {'text': 'Hallo, Welt!'} else: data = {'text': 'Hello, world!'} headers = {'Vary': 'Accept-Language'} return http.JSONResponse(data, status_code=200, headers=headers) For other content types, use a Response class, and set the content-type header explicitly. from webtypes import http def hello_world() -> http.Response: content = 'Hello, world!' headers = {'Content-Type': 'text/plain'} return http.Response(content, headers=headers)","title":"Responses"},{"location":"api-guide/routing/","text":"Routing Use {curly_braces} in your URL conf to include a URL path parameter. from webtypes import App, Route def echo_username(username: str) -> dict: return {'message': 'Welcome, %s!' % username} routes = [ Route('/users/{username}/', method='GET', handler=echo_username) ] app = App(routes=routes) Use type annotation on a handler to match integers or floats in the URL string. from webtypes import App, Route, exceptions USERS = {1: 'hazel', 2: 'james', 3: 'ana'} def echo_username(user_id: int) -> dict: if user_id not in USERS: raise exceptions.NotFound() return {'message': 'Welcome, %s!' % USERS[user_id]} routes = [ Route('/users/{user_id}/', method='GET', handler=echo_username) ] app = App(routes=routes) If you want to capture a complete URL path parameter including any / characters then use {+curly_braces} . routes = [ Route('/static/{+path}', method='GET', handler=serve_file) ] app = App(routes=routes) Building URLS You can generate URL strings that match your routing configuration by using app.reverse_url(name, **parameters) . from webtypes import App, Route, exceptions USERS = {1: 'hazel', 2: 'james', 3: 'ana'} def list_users(app: App) -> list: return [ { 'username': username, 'url': app.reverse_url('get_user', user_id=user_id) } for user_id, username in USERS.items() ] def get_user(app: App, user_id: int) -> dict: if user_id not in USERS: raise exceptions.NotFound() return { 'username': USERS[user_id], 'url': app.reverse_url('get_user', user_id=user_id) } routes = [ Route('/users/', method='GET', handler=list_users), Route('/users/{user_id}/', method='GET', handler=get_user) ] app = App(routes=routes) Routing in larger projects In many projects you may want to split your routing into different sections. Use Include to add a list of routes under a single URL prefix. myproject/users.py from webtypes import App, Route, exceptions USERS = {1: 'hazel', 2: 'james', 3: 'ana'} def list_users(app: App) -> list: return [ { 'username': username, 'url': app.reverse_url('users:get_user', user_id=user_id) } for user_id, username in USERS.items() ] def get_user(app: App, user_id: int) -> dict: if user_id not in USERS: raise exceptions.NotFound() return { 'username': USERS[user_id], 'url': app.reverse_url('users:get_user', user_id=user_id) } routes = [ Route('/', method='GET', handler=list_users), Route('/{user_id}', method='GET', handler=get_user), ] app.py: from webtypes import App, Include from myproject import users routes = [ Include('/users', name='users', routes=users.routes), ... ] app = App(routes=routes)","title":"Routing"},{"location":"api-guide/routing/#routing","text":"Use {curly_braces} in your URL conf to include a URL path parameter. from webtypes import App, Route def echo_username(username: str) -> dict: return {'message': 'Welcome, %s!' % username} routes = [ Route('/users/{username}/', method='GET', handler=echo_username) ] app = App(routes=routes) Use type annotation on a handler to match integers or floats in the URL string. from webtypes import App, Route, exceptions USERS = {1: 'hazel', 2: 'james', 3: 'ana'} def echo_username(user_id: int) -> dict: if user_id not in USERS: raise exceptions.NotFound() return {'message': 'Welcome, %s!' % USERS[user_id]} routes = [ Route('/users/{user_id}/', method='GET', handler=echo_username) ] app = App(routes=routes) If you want to capture a complete URL path parameter including any / characters then use {+curly_braces} . routes = [ Route('/static/{+path}', method='GET', handler=serve_file) ] app = App(routes=routes)","title":"Routing"},{"location":"api-guide/routing/#building-urls","text":"You can generate URL strings that match your routing configuration by using app.reverse_url(name, **parameters) . from webtypes import App, Route, exceptions USERS = {1: 'hazel', 2: 'james', 3: 'ana'} def list_users(app: App) -> list: return [ { 'username': username, 'url': app.reverse_url('get_user', user_id=user_id) } for user_id, username in USERS.items() ] def get_user(app: App, user_id: int) -> dict: if user_id not in USERS: raise exceptions.NotFound() return { 'username': USERS[user_id], 'url': app.reverse_url('get_user', user_id=user_id) } routes = [ Route('/users/', method='GET', handler=list_users), Route('/users/{user_id}/', method='GET', handler=get_user) ] app = App(routes=routes)","title":"Building URLS"},{"location":"api-guide/routing/#routing-in-larger-projects","text":"In many projects you may want to split your routing into different sections. Use Include to add a list of routes under a single URL prefix. myproject/users.py from webtypes import App, Route, exceptions USERS = {1: 'hazel', 2: 'james', 3: 'ana'} def list_users(app: App) -> list: return [ { 'username': username, 'url': app.reverse_url('users:get_user', user_id=user_id) } for user_id, username in USERS.items() ] def get_user(app: App, user_id: int) -> dict: if user_id not in USERS: raise exceptions.NotFound() return { 'username': USERS[user_id], 'url': app.reverse_url('users:get_user', user_id=user_id) } routes = [ Route('/', method='GET', handler=list_users), Route('/{user_id}', method='GET', handler=get_user), ] app.py: from webtypes import App, Include from myproject import users routes = [ Include('/users', name='users', routes=users.routes), ... ] app = App(routes=routes)","title":"Routing in larger projects"},{"location":"api-guide/static-files/","text":"Static Files You'll need to install whitenoise to use the default static files backend. If you're using ASyncApp you'll also need to install aiofiles . To include static files in your application, create a directory to contain the static files, and include it with the static_dir argument when instantiating the app. import os BASE_DIR = os.path.dirname(__file__) STATIC_DIR = os.path.join(BASE_DIR, 'static') ... app = App(routes=routes, static_dir=STATIC_DIR) The default behavior is to serve static files from the URL prefix /static/ . You can modify this by also including a static_url argument.","title":"Static Files"},{"location":"api-guide/static-files/#static-files","text":"You'll need to install whitenoise to use the default static files backend. If you're using ASyncApp you'll also need to install aiofiles . To include static files in your application, create a directory to contain the static files, and include it with the static_dir argument when instantiating the app. import os BASE_DIR = os.path.dirname(__file__) STATIC_DIR = os.path.join(BASE_DIR, 'static') ... app = App(routes=routes, static_dir=STATIC_DIR) The default behavior is to serve static files from the URL prefix /static/ . You can modify this by also including a static_url argument.","title":"Static Files"},{"location":"api-guide/templates/","text":"Templates webtypes is particularly designed around building APIs, but is equally capable of being used to build web applications. Configuration You'll need to install jinja2 to use the default template backend. To include templates in your application, create a directory to contain the templates, and include it with the template_dir argument when instantiating the app. import os BASE_DIR = os.path.dirname(__file__) TEMPLATE_DIR = os.path.join(BASE_DIR, 'templates') ... app = App(routes=routes, template_dir=TEMPLATE_DIR) Rendering templates To render a template, use app.render_template(template_name, **context) . templates/index.html : <html> <body> {% if name %} <h1>Hello, {{ name }}!</h1> {% else %} <h1>Hello!</h1> {% endif %} </body> </html> app.py : import os from webtypes import App, Route BASE_DIR = os.path.dirname(__file__) TEMPLATE_DIR = os.path.join(BASE_DIR, 'templates') def welcome(app: App, name=None): return app.render_template('index.html', name=name) routes = [ Route('/', method='GET', handler=welcome), ] app = App(routes=routes, template_dir=TEMPLATE_DIR) if __name__ == '__main__': app.serve('127.0.0.1', 8080, use_debugger=True) You can configure where templates are served from by using the template_dir argument when instantiating an application.","title":"Templates"},{"location":"api-guide/templates/#templates","text":"webtypes is particularly designed around building APIs, but is equally capable of being used to build web applications.","title":"Templates"},{"location":"api-guide/templates/#configuration","text":"You'll need to install jinja2 to use the default template backend. To include templates in your application, create a directory to contain the templates, and include it with the template_dir argument when instantiating the app. import os BASE_DIR = os.path.dirname(__file__) TEMPLATE_DIR = os.path.join(BASE_DIR, 'templates') ... app = App(routes=routes, template_dir=TEMPLATE_DIR)","title":"Configuration"},{"location":"api-guide/templates/#rendering-templates","text":"To render a template, use app.render_template(template_name, **context) . templates/index.html : <html> <body> {% if name %} <h1>Hello, {{ name }}!</h1> {% else %} <h1>Hello!</h1> {% endif %} </body> </html> app.py : import os from webtypes import App, Route BASE_DIR = os.path.dirname(__file__) TEMPLATE_DIR = os.path.join(BASE_DIR, 'templates') def welcome(app: App, name=None): return app.render_template('index.html', name=name) routes = [ Route('/', method='GET', handler=welcome), ] app = App(routes=routes, template_dir=TEMPLATE_DIR) if __name__ == '__main__': app.serve('127.0.0.1', 8080, use_debugger=True) You can configure where templates are served from by using the template_dir argument when instantiating an application.","title":"Rendering templates"},{"location":"api-guide/testing/","text":"Testing webtypes isn't coupled to any particular testing framework. One good option for writing your test cases is the pytest framework . To make it easier to run tests against your application, webtypes includes a test client, that acts as an adapter for the excellent python requests library, allowing you to make requests directly to your application. You can use the API test client with any WSGI or ASGI application. from webtypes import test from myproject import app client = test.TestClient(app) def test_hello_world(): response = client.get('/hello_world/') assert response.status_code == 200 assert response.json() == {'hello': 'world'}","title":"Testing"},{"location":"api-guide/testing/#testing","text":"webtypes isn't coupled to any particular testing framework. One good option for writing your test cases is the pytest framework . To make it easier to run tests against your application, webtypes includes a test client, that acts as an adapter for the excellent python requests library, allowing you to make requests directly to your application. You can use the API test client with any WSGI or ASGI application. from webtypes import test from myproject import app client = test.TestClient(app) def test_hello_world(): response = client.get('/hello_world/') assert response.status_code == 200 assert response.json() == {'hello': 'world'}","title":"Testing"},{"location":"api-guide/type-system/","text":"Type System webtypes comes with a type system that allows you to express constraints on the expected inputs and outputs of your interface. The Type class Here\u2019s a quick example of what the type system in webtypes looks like: from webtypes import types, validators class Product(types.Type): name = validators.String(max_length=100) rating = validators.Integer(minimum=1, maximum=5) in_stock = validators.Boolean(default=False) size = validators.String(enum=['small', 'medium', 'large']) You can use the type system both for validation of incoming request data, and for serializing outgoing response data. Invalid data will result in a ValidationError being raised. >>> data = {'name': 't-shirt', 'size': 'big'} >>> product = Product(data) webtypes.exceptions.ValidationError: {'rating': 'This field is required.', 'size': 'Must be a valid choice.'} Valid data will instantiate a new Type instance. >>> data = {'name': 't-shirt', 'rating': 4, 'size': 'large'} >>> product = Product(data) <Product(name='t-shirt', rating=4, in_stock=False, size='large')> You can access the values on a Type instance as attributes. >>> product.name 't-shirt' Or treat a Type as a dictionary-like object. >>> product['rating']: 4 >>> dict(product) {'name': 't-shirt', 'rating': 4, 'in_stock': False, 'size': 'large'} Nested types You can include Type classes as fields on other Type classes, like so: class Location(types.Type): latitude = validators.Number(maximum=90.0, minimum=-90.0) longitude = validators.Number(maximum=180.0, minimum=-180.0) class Event(types.Type): location = Location name = validators.String(max_length=100) Validation You can use webtypes Type classes as annotations inside your handler functions. When you do so, validation will be handled automatically prior to running the handler function. The type information will also be made available in the application's API Schema. def create_product(product: Product): # Save a new product record in the database. ... routes = [ Route('/create_product/', method='POST', handler=create_product) ] Serialization You may also want to using the type system for data serialization, and include the type as a return annotation on handler functions. Again, doing so will expose the type information to the application's API Schema, and will help ensure that the information your system returns matches its documented return types. import typing def list_products() -> typing.List[Product]: queryset = ... # Query returning products from a data store. return [Product(record) for record in queryset] Including additional validation If you have validation rules that cannot be expressed with the default types, you can include these by subclass the __init__ method on the class. This method should return the validated data, or raise a ValidationError . from webtypes import exceptions, types, validators class Organisation(types.Type): is_premium = validators.Boolean() expiry_date = validators.Date(allow_null=True) def __init__(self, *args, **kwargs): value = super().__init__(*args, **kwargs) if value.is_premium and value.expiry_date is not None: message = 'premium organisations should not have any expiry_date set.' raise exceptions.ValidationError(message) return value API Reference The following typesystem types are supported: String Validates string data. default - A default to be used if a field using this typesystem is missing from a parent Type . title - A title to use in API schemas and documentation. description - A description to use in API schemas and documentation. max_length - A maximum valid length for the data. min_length - A minimum valid length for the data. pattern - A string value, giving a regular expression that the data must match. enum - A list of valid strings that the input must match against. format - An identifier indicating a complex datatype with a string representation. For example \"date\" , to represent an ISO 8601 formatted date string. allow_null - Indicates if None should be considered a valid value. Defaults to False . If set to True and no default value is specified then default= None will be used. Number Validates numeric data. default - A default to be used if a field using this typesystem is missing from a parent Type . title - A title to use in API schemas and documentation. description - A description to use in API schemas and documentation. maximum - A float representing the maximum valid value for the data. minimum - A float representing the minimum valid value for the data. exclusive_maximum - True for an exclusive maximum limit. Defaults to False . exclusive_minimum - True for an exclusive minimum limit. Defaults to False . multiple_of - A float that the data must be strictly divisible by, in order to be valid. enum - A list of valid numbers that the input must match against. allow_null - Indicates if None should be considered a valid value. Defaults to False . If set to True and no default value is specified then default= None will be used. Integer Validates integer data. default - A default to be used if a field using this typesystem is missing from a parent Type . title - A title to use in API schemas and documentation. description - A description to use in API schemas and documentation. maximum - An int representing the maximum valid value for the data. minimum - An int representing the minimum valid value for the data. exclusive_maximum - True for an exclusive maximum limit. Defaults to False . exclusive_minimum - True for an exclusive minimum limit. Defaults to False . multiple_of - An integer that the data must be strictly divisible by, in order to be valid. enum - A list of valid numbers that the input must match against. allow_null - Indicates if None should be considered a valid value. Defaults to False . If set to True and no default value is specified then default= None will be used. Boolean Validates boolean input. default - A default to be used if a field using this typesystem is missing from a parent Type . title - A title to use in API schemas and documentation. description - A description to use in API schemas and documentation. allow_null - Indicates if None should be considered a valid value. Defaults to False . If set to True and no default value is specified then default= None will be used. Object Validates dictionary input. default - A default to be used if a field using this typesystem is missing from a parent Type . title - A title to use in API schemas and documentation. description - A description to use in API schemas and documentation. properties - A dictionary mapping string key names to child validators. pattern_properties - A dictionary mapping regex key names to child validators. additional_properties - True if additional properties should be allowed. None if additional properties should be discarded. False if additional properties should raise errors. Or a validator instance, to type check any additional properties against. min_properties - An integer indicating the minimum number of properties that may be present. Defaults to None . max_properties - An integer indicating the maximum number of properties that may be present. Defaults to None . required - A list of strings, indicating which properties are required. allow_null - Indicates if None should be considered a valid value. Defaults to False . If set to True and no default value is specified then default= None will be used. You'll typically want to use the simpler declarative Type style for describing dictionary inputs, but the Object validator may be useful if you need more general purpose validation. Array Validates list input. default - A default to be used if a field using this typesystem is missing from a parent Type . title - A title to use in API schemas and documentation. description - A description to use in API schemas and documentation. items - A validator or a list of validators. additional_items - Whether additional items past the end of the listed typesystem types are permitted. min_items - The minimum number of items the array must contain. max_items - The maximum number of items the array must contain. unique_items - Whether repeated items are permitted in the array. allow_null - Indicates if None should be considered a valid value. Defaults to False . If set to True and no default value is specified then default= None will be used. Formats The following validators return a native python representation, but can be serialized to strings. Let's declare a new type to see how they work... from webtypes import types, validators class Event(types.Type): when = validators.DateTime() description = validators.String(max_length=100) When accessed as attributes on a type, these validators return the native python value. >>> data = {'when': '2021-06-15T12:31:38.269545', 'description': 'New customer signup'} >>> event = Event(data) >>> event.when datetime.datetime(2021, 6, 15, 12, 31, 38, 269545) You can also access the serialized string representation if needed. >>> event['when'] '2021-04-11T12:31:38.269545' >>> dict(event) {'when': '2021-04-11T12:31:38.269545', 'description': 'New customer signup'} Date default - A default to be used if a field using this typesystem is missing from a parent Type . title - A title to use in API schemas and documentation. description - A description to use in API schemas and documentation. allow_null - Indicates if None should be considered a valid value. Defaults to False . Time default - A default to be used if a field using this typesystem is missing from a parent Type . title - A title to use in API schemas and documentation. description - A description to use in API schemas and documentation. allow_null - Indicates if None should be considered a valid value. Defaults to False . DateTime default - A default to be used if a field using this typesystem is missing from a parent Type . title - A title to use in API schemas and documentation. description - A description to use in API schemas and documentation. allow_null - Indicates if None should be considered a valid value. Defaults to False .","title":"The Type System"},{"location":"api-guide/type-system/#type-system","text":"webtypes comes with a type system that allows you to express constraints on the expected inputs and outputs of your interface.","title":"Type System"},{"location":"api-guide/type-system/#the-type-class","text":"Here\u2019s a quick example of what the type system in webtypes looks like: from webtypes import types, validators class Product(types.Type): name = validators.String(max_length=100) rating = validators.Integer(minimum=1, maximum=5) in_stock = validators.Boolean(default=False) size = validators.String(enum=['small', 'medium', 'large']) You can use the type system both for validation of incoming request data, and for serializing outgoing response data. Invalid data will result in a ValidationError being raised. >>> data = {'name': 't-shirt', 'size': 'big'} >>> product = Product(data) webtypes.exceptions.ValidationError: {'rating': 'This field is required.', 'size': 'Must be a valid choice.'} Valid data will instantiate a new Type instance. >>> data = {'name': 't-shirt', 'rating': 4, 'size': 'large'} >>> product = Product(data) <Product(name='t-shirt', rating=4, in_stock=False, size='large')> You can access the values on a Type instance as attributes. >>> product.name 't-shirt' Or treat a Type as a dictionary-like object. >>> product['rating']: 4 >>> dict(product) {'name': 't-shirt', 'rating': 4, 'in_stock': False, 'size': 'large'}","title":"The Type class"},{"location":"api-guide/type-system/#nested-types","text":"You can include Type classes as fields on other Type classes, like so: class Location(types.Type): latitude = validators.Number(maximum=90.0, minimum=-90.0) longitude = validators.Number(maximum=180.0, minimum=-180.0) class Event(types.Type): location = Location name = validators.String(max_length=100)","title":"Nested types"},{"location":"api-guide/type-system/#validation","text":"You can use webtypes Type classes as annotations inside your handler functions. When you do so, validation will be handled automatically prior to running the handler function. The type information will also be made available in the application's API Schema. def create_product(product: Product): # Save a new product record in the database. ... routes = [ Route('/create_product/', method='POST', handler=create_product) ]","title":"Validation"},{"location":"api-guide/type-system/#serialization","text":"You may also want to using the type system for data serialization, and include the type as a return annotation on handler functions. Again, doing so will expose the type information to the application's API Schema, and will help ensure that the information your system returns matches its documented return types. import typing def list_products() -> typing.List[Product]: queryset = ... # Query returning products from a data store. return [Product(record) for record in queryset]","title":"Serialization"},{"location":"api-guide/type-system/#including-additional-validation","text":"If you have validation rules that cannot be expressed with the default types, you can include these by subclass the __init__ method on the class. This method should return the validated data, or raise a ValidationError . from webtypes import exceptions, types, validators class Organisation(types.Type): is_premium = validators.Boolean() expiry_date = validators.Date(allow_null=True) def __init__(self, *args, **kwargs): value = super().__init__(*args, **kwargs) if value.is_premium and value.expiry_date is not None: message = 'premium organisations should not have any expiry_date set.' raise exceptions.ValidationError(message) return value","title":"Including additional validation"},{"location":"api-guide/type-system/#api-reference","text":"The following typesystem types are supported:","title":"API Reference"},{"location":"api-guide/type-system/#string","text":"Validates string data. default - A default to be used if a field using this typesystem is missing from a parent Type . title - A title to use in API schemas and documentation. description - A description to use in API schemas and documentation. max_length - A maximum valid length for the data. min_length - A minimum valid length for the data. pattern - A string value, giving a regular expression that the data must match. enum - A list of valid strings that the input must match against. format - An identifier indicating a complex datatype with a string representation. For example \"date\" , to represent an ISO 8601 formatted date string. allow_null - Indicates if None should be considered a valid value. Defaults to False . If set to True and no default value is specified then default= None will be used.","title":"String"},{"location":"api-guide/type-system/#number","text":"Validates numeric data. default - A default to be used if a field using this typesystem is missing from a parent Type . title - A title to use in API schemas and documentation. description - A description to use in API schemas and documentation. maximum - A float representing the maximum valid value for the data. minimum - A float representing the minimum valid value for the data. exclusive_maximum - True for an exclusive maximum limit. Defaults to False . exclusive_minimum - True for an exclusive minimum limit. Defaults to False . multiple_of - A float that the data must be strictly divisible by, in order to be valid. enum - A list of valid numbers that the input must match against. allow_null - Indicates if None should be considered a valid value. Defaults to False . If set to True and no default value is specified then default= None will be used.","title":"Number"},{"location":"api-guide/type-system/#integer","text":"Validates integer data. default - A default to be used if a field using this typesystem is missing from a parent Type . title - A title to use in API schemas and documentation. description - A description to use in API schemas and documentation. maximum - An int representing the maximum valid value for the data. minimum - An int representing the minimum valid value for the data. exclusive_maximum - True for an exclusive maximum limit. Defaults to False . exclusive_minimum - True for an exclusive minimum limit. Defaults to False . multiple_of - An integer that the data must be strictly divisible by, in order to be valid. enum - A list of valid numbers that the input must match against. allow_null - Indicates if None should be considered a valid value. Defaults to False . If set to True and no default value is specified then default= None will be used.","title":"Integer"},{"location":"api-guide/type-system/#boolean","text":"Validates boolean input. default - A default to be used if a field using this typesystem is missing from a parent Type . title - A title to use in API schemas and documentation. description - A description to use in API schemas and documentation. allow_null - Indicates if None should be considered a valid value. Defaults to False . If set to True and no default value is specified then default= None will be used.","title":"Boolean"},{"location":"api-guide/type-system/#object","text":"Validates dictionary input. default - A default to be used if a field using this typesystem is missing from a parent Type . title - A title to use in API schemas and documentation. description - A description to use in API schemas and documentation. properties - A dictionary mapping string key names to child validators. pattern_properties - A dictionary mapping regex key names to child validators. additional_properties - True if additional properties should be allowed. None if additional properties should be discarded. False if additional properties should raise errors. Or a validator instance, to type check any additional properties against. min_properties - An integer indicating the minimum number of properties that may be present. Defaults to None . max_properties - An integer indicating the maximum number of properties that may be present. Defaults to None . required - A list of strings, indicating which properties are required. allow_null - Indicates if None should be considered a valid value. Defaults to False . If set to True and no default value is specified then default= None will be used. You'll typically want to use the simpler declarative Type style for describing dictionary inputs, but the Object validator may be useful if you need more general purpose validation.","title":"Object"},{"location":"api-guide/type-system/#array","text":"Validates list input. default - A default to be used if a field using this typesystem is missing from a parent Type . title - A title to use in API schemas and documentation. description - A description to use in API schemas and documentation. items - A validator or a list of validators. additional_items - Whether additional items past the end of the listed typesystem types are permitted. min_items - The minimum number of items the array must contain. max_items - The maximum number of items the array must contain. unique_items - Whether repeated items are permitted in the array. allow_null - Indicates if None should be considered a valid value. Defaults to False . If set to True and no default value is specified then default= None will be used.","title":"Array"},{"location":"api-guide/type-system/#formats","text":"The following validators return a native python representation, but can be serialized to strings. Let's declare a new type to see how they work... from webtypes import types, validators class Event(types.Type): when = validators.DateTime() description = validators.String(max_length=100) When accessed as attributes on a type, these validators return the native python value. >>> data = {'when': '2021-06-15T12:31:38.269545', 'description': 'New customer signup'} >>> event = Event(data) >>> event.when datetime.datetime(2021, 6, 15, 12, 31, 38, 269545) You can also access the serialized string representation if needed. >>> event['when'] '2021-04-11T12:31:38.269545' >>> dict(event) {'when': '2021-04-11T12:31:38.269545', 'description': 'New customer signup'}","title":"Formats"},{"location":"api-guide/type-system/#date","text":"default - A default to be used if a field using this typesystem is missing from a parent Type . title - A title to use in API schemas and documentation. description - A description to use in API schemas and documentation. allow_null - Indicates if None should be considered a valid value. Defaults to False .","title":"Date"},{"location":"api-guide/type-system/#time","text":"default - A default to be used if a field using this typesystem is missing from a parent Type . title - A title to use in API schemas and documentation. description - A description to use in API schemas and documentation. allow_null - Indicates if None should be considered a valid value. Defaults to False .","title":"Time"},{"location":"api-guide/type-system/#datetime","text":"default - A default to be used if a field using this typesystem is missing from a parent Type . title - A title to use in API schemas and documentation. description - A description to use in API schemas and documentation. allow_null - Indicates if None should be considered a valid value. Defaults to False .","title":"DateTime"},{"location":"topics/release-notes/","text":"Release Notes Version 0.5.x 0.5.40 Raise TypeError on unserializable JSON. Fix resource leak on ASyncStaticFiles 0.5.39 Improve error messages on 'required' case. 0.5.38 Redesign API for retriving OpenAPI and Swagger validation errors. 0.5.37 Swagger: Fixes to security and securityDefinitions. 0.5.36 Resolve issue with filename argument on errors. 0.5.35 Support optional filename argument against errors. 0.5.34 OpenAPI: Add 'RequestBodies' to components. OpenAPI: 'security' must be a list. 0.5.33 More robust handling for None in tags or titles in swagger/openapi codecs. 0.5.32 Add 'swaggerui' option to docs/theme , alongside existing 'redoc', 'webtypes'. 0.5.31 Add 'docs/theme' section to .webtypes.yml config file validation. 0.5.30 Drop erronous print 0.5.29 Initial support for validating .webtypes.yml config file. 0.5.28 First pass at Swagger 2 support (alongside existing OpenAPI 3 support). 0.5.27 Handle error formatting for missing keys. 0.5.26 Fix error reporting when YAML parse errors occur. 0.5.25 More robust YAML errors. 0.5.24 Fix issues with Docs API theme. 0.5.23 Catch and handle yaml.parser.ParserError when parsing OpenAPI. 0.5.22 Fix error when using list or dict as response annotations. Fix for error handling in ASyncApp. When attribute does not exist, raise AttributeError on Type instead of KeyError . Fix \"not JSON serializable\" error condition. 0.5.21 Fix API docs in ASyncApp when static_dir is not defined. 0.5.20 Fix static file links when rendering docs in ASyncApp 0.5.19 API Documentation theme 0.5.18 Fix parsing of OpenAPI documents with request bodies. 0.5.17 Add 'SecurityScheme' to OpenAPI and allow 'responses' to use reference objects. 0.5.16 Improved error formatting. 0.5.15 Fix 'responses' and 'parameters' in OpenAPI spec. 0.5.14 Added 'headers' to OpenAPI spec. 0.5.13 Added webtypes docs <schema> and webtypes validate <schema> . 0.5.12 The WSGI exc_info argument is a positional argument, not a keyword argument. 0.5.11 Add API documentation support. 0.5.10 Handle multiple keys in multipart content. 0.5.9 allow_null=True sets default to None unless otherwise specified. 0.5.8 Add support for response schemas to OpenAPI output. 0.5.7 All Type annotations for GET handlers. 0.5.6 Fix bool annotations. 0.5.5 Fix nested types. 0.5.4 Event hooks instantiated on each request/response cycle. 0.5.3 Support multipart and urlencoded content in RequestData . Reverse ordering of on_response and on_error event hooks. 0.5.2 Graceful handling of cases where on_error handling raises errors. 0.5.1 Fix for handlers than annotate Response , not being available to the ReturnValue annotation when render_response is called. 0.5 Should have introduced a proper version bump, given the 0.4.5 changes. Version 0.4.x 0.4.5 on_response now runs for both regular reponses and handled exceptions. on_error now only runs for unhandled exceptions (ie. 500 reponses). Return 500 responses on error. Test client raises exceptions instead of returning 500 responses. Add debug flag to app.serve(), to switch between debugger vs. plain responses. Include http.QueryParam annotations in schema output, as one of the parameters. Include handler docstring in schema output, as the 'description'. Allow subclassing of type.Type . 0.4.4 OpenAPI schema uses requestBody instead of the incorrect responseBody . Include http.Response component. Drop requirement of returning response from event hooks. Use shutil.move in preference to os.rename in DownloadCodec . 0.4.3 Drop erroneous commit. 0.4.2 Move RESPONSE_STATUS_TEXT out of http and into wsgi . 0.4.1 Update package info. 0.4 The Version 0.4 release is a significant re-working of the webtypes codebase. As part of this there are a number of features that have been removed and not yet made their way back in to the project: The API Docs have not yet been re-introduced. The command routing has not yet been re-introduced. The webtypes command line tool has not yet been re-introduced. The ORM components have been removed. We'll be pushing for this kind of functionality to be addressed as third-party packages instead. However the overall state of the project is in a much better place than it was in 0.3, and I'm confident that we've now got a great base to build on. We've also gained a number of new features and improvements: ASGI compatible. You'll be able to use either uvicorn or daphne as servers for use with ASyncApp. OpenAPI is now the default schema representation. We now have an event hooks API. The dependency injection now has a much cleaner, simpler API and implementation. The type system now has a much cleaner, simpler API and implementation. Settings are much cleaner, with each component configured at the point of instantiation, rather than one big global settings object that's available everywhere. If you do need to continue working against the 0.3 version, you should refer to the older documentation on GitHub . You should also make sure to serve any async applications using uvicorn <= 0.0.15, which uses the pre-ASGI interface style.","title":"Release Notes"},{"location":"topics/release-notes/#release-notes","text":"","title":"Release Notes"},{"location":"topics/release-notes/#version-05x","text":"","title":"Version 0.5.x"},{"location":"topics/release-notes/#0540","text":"Raise TypeError on unserializable JSON. Fix resource leak on ASyncStaticFiles","title":"0.5.40"},{"location":"topics/release-notes/#0539","text":"Improve error messages on 'required' case.","title":"0.5.39"},{"location":"topics/release-notes/#0538","text":"Redesign API for retriving OpenAPI and Swagger validation errors.","title":"0.5.38"},{"location":"topics/release-notes/#0537","text":"Swagger: Fixes to security and securityDefinitions.","title":"0.5.37"},{"location":"topics/release-notes/#0536","text":"Resolve issue with filename argument on errors.","title":"0.5.36"},{"location":"topics/release-notes/#0535","text":"Support optional filename argument against errors.","title":"0.5.35"},{"location":"topics/release-notes/#0534","text":"OpenAPI: Add 'RequestBodies' to components. OpenAPI: 'security' must be a list.","title":"0.5.34"},{"location":"topics/release-notes/#0533","text":"More robust handling for None in tags or titles in swagger/openapi codecs.","title":"0.5.33"},{"location":"topics/release-notes/#0532","text":"Add 'swaggerui' option to docs/theme , alongside existing 'redoc', 'webtypes'.","title":"0.5.32"},{"location":"topics/release-notes/#0531","text":"Add 'docs/theme' section to .webtypes.yml config file validation.","title":"0.5.31"},{"location":"topics/release-notes/#0530","text":"Drop erronous print","title":"0.5.30"},{"location":"topics/release-notes/#0529","text":"Initial support for validating .webtypes.yml config file.","title":"0.5.29"},{"location":"topics/release-notes/#0528","text":"First pass at Swagger 2 support (alongside existing OpenAPI 3 support).","title":"0.5.28"},{"location":"topics/release-notes/#0527","text":"Handle error formatting for missing keys.","title":"0.5.27"},{"location":"topics/release-notes/#0526","text":"Fix error reporting when YAML parse errors occur.","title":"0.5.26"},{"location":"topics/release-notes/#0525","text":"More robust YAML errors.","title":"0.5.25"},{"location":"topics/release-notes/#0524","text":"Fix issues with Docs API theme.","title":"0.5.24"},{"location":"topics/release-notes/#0523","text":"Catch and handle yaml.parser.ParserError when parsing OpenAPI.","title":"0.5.23"},{"location":"topics/release-notes/#0522","text":"Fix error when using list or dict as response annotations. Fix for error handling in ASyncApp. When attribute does not exist, raise AttributeError on Type instead of KeyError . Fix \"not JSON serializable\" error condition.","title":"0.5.22"},{"location":"topics/release-notes/#0521","text":"Fix API docs in ASyncApp when static_dir is not defined.","title":"0.5.21"},{"location":"topics/release-notes/#0520","text":"Fix static file links when rendering docs in ASyncApp","title":"0.5.20"},{"location":"topics/release-notes/#0519","text":"API Documentation theme","title":"0.5.19"},{"location":"topics/release-notes/#0518","text":"Fix parsing of OpenAPI documents with request bodies.","title":"0.5.18"},{"location":"topics/release-notes/#0517","text":"Add 'SecurityScheme' to OpenAPI and allow 'responses' to use reference objects.","title":"0.5.17"},{"location":"topics/release-notes/#0516","text":"Improved error formatting.","title":"0.5.16"},{"location":"topics/release-notes/#0515","text":"Fix 'responses' and 'parameters' in OpenAPI spec.","title":"0.5.15"},{"location":"topics/release-notes/#0514","text":"Added 'headers' to OpenAPI spec.","title":"0.5.14"},{"location":"topics/release-notes/#0513","text":"Added webtypes docs <schema> and webtypes validate <schema> .","title":"0.5.13"},{"location":"topics/release-notes/#0512","text":"The WSGI exc_info argument is a positional argument, not a keyword argument.","title":"0.5.12"},{"location":"topics/release-notes/#0511","text":"Add API documentation support.","title":"0.5.11"},{"location":"topics/release-notes/#0510","text":"Handle multiple keys in multipart content.","title":"0.5.10"},{"location":"topics/release-notes/#059","text":"allow_null=True sets default to None unless otherwise specified.","title":"0.5.9"},{"location":"topics/release-notes/#058","text":"Add support for response schemas to OpenAPI output.","title":"0.5.8"},{"location":"topics/release-notes/#057","text":"All Type annotations for GET handlers.","title":"0.5.7"},{"location":"topics/release-notes/#056","text":"Fix bool annotations.","title":"0.5.6"},{"location":"topics/release-notes/#055","text":"Fix nested types.","title":"0.5.5"},{"location":"topics/release-notes/#054","text":"Event hooks instantiated on each request/response cycle.","title":"0.5.4"},{"location":"topics/release-notes/#053","text":"Support multipart and urlencoded content in RequestData . Reverse ordering of on_response and on_error event hooks.","title":"0.5.3"},{"location":"topics/release-notes/#052","text":"Graceful handling of cases where on_error handling raises errors.","title":"0.5.2"},{"location":"topics/release-notes/#051","text":"Fix for handlers than annotate Response , not being available to the ReturnValue annotation when render_response is called.","title":"0.5.1"},{"location":"topics/release-notes/#05","text":"Should have introduced a proper version bump, given the 0.4.5 changes.","title":"0.5"},{"location":"topics/release-notes/#version-04x","text":"","title":"Version 0.4.x"},{"location":"topics/release-notes/#045","text":"on_response now runs for both regular reponses and handled exceptions. on_error now only runs for unhandled exceptions (ie. 500 reponses). Return 500 responses on error. Test client raises exceptions instead of returning 500 responses. Add debug flag to app.serve(), to switch between debugger vs. plain responses. Include http.QueryParam annotations in schema output, as one of the parameters. Include handler docstring in schema output, as the 'description'. Allow subclassing of type.Type .","title":"0.4.5"},{"location":"topics/release-notes/#044","text":"OpenAPI schema uses requestBody instead of the incorrect responseBody . Include http.Response component. Drop requirement of returning response from event hooks. Use shutil.move in preference to os.rename in DownloadCodec .","title":"0.4.4"},{"location":"topics/release-notes/#043","text":"Drop erroneous commit.","title":"0.4.3"},{"location":"topics/release-notes/#042","text":"Move RESPONSE_STATUS_TEXT out of http and into wsgi .","title":"0.4.2"},{"location":"topics/release-notes/#041","text":"Update package info.","title":"0.4.1"},{"location":"topics/release-notes/#04","text":"The Version 0.4 release is a significant re-working of the webtypes codebase. As part of this there are a number of features that have been removed and not yet made their way back in to the project: The API Docs have not yet been re-introduced. The command routing has not yet been re-introduced. The webtypes command line tool has not yet been re-introduced. The ORM components have been removed. We'll be pushing for this kind of functionality to be addressed as third-party packages instead. However the overall state of the project is in a much better place than it was in 0.3, and I'm confident that we've now got a great base to build on. We've also gained a number of new features and improvements: ASGI compatible. You'll be able to use either uvicorn or daphne as servers for use with ASyncApp. OpenAPI is now the default schema representation. We now have an event hooks API. The dependency injection now has a much cleaner, simpler API and implementation. The type system now has a much cleaner, simpler API and implementation. Settings are much cleaner, with each component configured at the point of instantiation, rather than one big global settings object that's available everywhere. If you do need to continue working against the 0.3 version, you should refer to the older documentation on GitHub . You should also make sure to serve any async applications using uvicorn <= 0.0.15, which uses the pre-ASGI interface style.","title":"0.4"}]}